{"name":"HTTP Task Queue (HTQ)","tagline":"Queues HTTP requests and stores the response in Redis for later retrieval","body":"# HTTP Task Queue (htq)\r\n\r\nThe HTTP Task Queue provides buffering between sending requests and receiving responses.\r\n\r\n\r\n- The client POSTs a description of a request to be sent at a later time\r\n- The client recieves an immediate response with a 303 See Other to the queued request with a status. This also contains a link to the response to be accessed once it has been received.\r\n- A worker sends the request in the background and stores the response to be retrieved by the client.\r\n- Once the request's status is in the `success`, `error`, or `timeout` state, the response is ready to be accessed.\r\n\r\nSee the [tutorial](#tutorial) below for further explanation.\r\n\r\n## Dependencies\r\n\r\n- Python 3.3+\r\n- Redis 2.4+\r\n\r\n## Command-line Interface\r\n\r\n```\r\n$ htq -h\r\nHTTP Task Queue (htq) command-line interface\r\n\r\nUsage:\r\n    htq server [--host <host>] [--port <port>] [--redis <redis>] [--debug]\r\n    htq worker [--threads <n>] [--redis <redis>] [--debug]\r\n\r\nOptions:\r\n    -h --help           Show this screen.\r\n    -v --version        Show version.\r\n    --debug             Turns on debug logging.\r\n    --host <host>       Host of the HTTP service [default: localhost].\r\n    --port <port>       Port of the HTTP service [default: 5000].\r\n    --redis <redis>     Host/port of the Redis server [default: localhost:6379].\r\n    --threads <n>       Number of threads a worker should spawn [default: 10].\r\n```\r\n\r\nRun the server for the HTTP REST interface.\r\n\r\n```\r\nhtq server\r\n```\r\n\r\nRun the worker to send requests and receive responses.\r\n\r\n```\r\nhtq worker\r\n```\r\n\r\n## API\r\n\r\n- `GET /` - Gets all queued requests.\r\n- `POST /` - Sends (queues) a request\r\n- `GET /<uuid>/` - Gets a request by UUID\r\n- `DELETE /<uuid>/` - Cancels a request, deleting it's response if already received\r\n- `GET /<uuid>/response/` - Gets a request's response if it has been received\r\n- `DELETE /<uuid>/response/` - Delete a request's response to clear up space\r\n\r\n## Tutorial\r\n\r\nStart the HTQ server:\r\n\r\n```bash\r\n$ htq server\r\nStarting htq REST server...\r\n * Running on http://localhost:5000/\r\n```\r\n\r\nSend a POST to the service with a JSON encoded structure of the request to be sent. This immediately returns a `303 See Other` response with the `Location` header to the request\r\n\r\n```bash\r\n$ curl -i -X POST -H 'Content-Type: application/json' http://localhost:5000 -d '{\"url\": \"http://httpbin.org/ip\"}'\r\nHTTP/1.0 303 SEE OTHER\r\nContent-Type: text/html; charset=utf-8\r\nContent-Length: 0\r\nLocation: http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 17:18:49 GMT\r\n```\r\n\r\nSee what the request resource looks like (use the URL from the `Location` header in your output):\r\n\r\n```bash\r\n$ curl -i http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/\r\nHTTP/1.0 200 OK\r\nContent-Type: application/json\r\nContent-Length: 185\r\nLink: <http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/response/>; rel=\"response\",\r\n      <http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/>; rel=\"self\",\r\n      <http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/status/>; rel=\"status\"\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 17:26:05 GMT\r\n\r\n{\r\n    \"timeout\": 60,\r\n    \"status\": \"queued\",\r\n    \"data\": null,\r\n    \"headers\": {},\r\n    \"url\": \"http://httpbin.org/ip\",\r\n    \"method\": \"get\",\r\n    \"uuid\": \"a936e1a1-68d8-4433-a0c0-4f4b2111670d\",\r\n    \"time\": 1412011537783\r\n}\r\n```\r\n\r\nThe above response shows the details of the request such as the URL, method, headers, and request data. Additionally metadata has been captured when the request was queued including the UUID, the time (in milliseconds) when the request was queued, the status of the request and a timeout. The `Link` header shows the related links from this resource including one to the response and the status. The status link is a lightweight:\r\n\r\n\r\n```bash\r\n$ curl -i http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/status/\r\nHTTP/1.0 200 OK\r\nContent-Type: application/json\r\nContent-Length: 20\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 17:30:21 GMT\r\n\r\n{\"status\": \"queued\"}\r\n```\r\n\r\nIf we were to `curl` the response link, it would block until the response is ready. Since we have not started a worker yet, this would be forever. Let's start a worker to actual send the request. Execute this in a separate shell:\r\n\r\n```bash\r\n$ htq worker --debug\r\nStarted 10 workers...\r\n[a936e1a1-68d8-4433-a0c0-4f4b2111670d] sending request...\r\n[a936e1a1-68d8-4433-a0c0-4f4b2111670d] response received\r\n```\r\n\r\nStarting the worker daemon immediately starts consuming the queue and sending the requests. As you can see, the one sent above has been sent and the response received. Let's check the status of our request.\r\n\r\n```bash\r\n$ curl -i http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/status/\r\nHTTP/1.0 200 OK\r\nContent-Type: application/json\r\nContent-Length: 21\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 17:36:56 GMT\r\n\r\n{\"status\": \"success\"}\r\n```\r\n\r\nSuccess! Now let's use the link to the response itself.\r\n\r\n```bash\r\n$ curl -i http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/response/\r\nHTTP/1.0 200 OK\r\nContent-Type: application/json\r\nContent-Length: 19291\r\nLink: <http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/>; rel=\"request\",\r\n      <http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/response/>; rel=\"self\"\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 17:38:22 GMT\r\n\r\n{\r\n    \"status\": \"success\",\r\n    \"time\": 1412012019457,\r\n    \"code\": 200,\r\n    \"reason\": \"OK\",\r\n    \"elapsed\": 79.81,\r\n    \"uuid\": \"62db48a4-e511-4c8e-9c11-32b39758d1ff\",\r\n    \"headers\": {\r\n        \"Age\": \"0\",\r\n        \"Content-Length\": \"32\",\r\n        \"Connection\": \"Keep-Alive\",\r\n        \"Access-Control-Allow-Origin\": \"*\",\r\n        \"Server\": \"gunicorn/18.0\",\r\n        \"Access-Control-Allow-Credentials\": \"true\",\r\n        \"Date\": \"Mon, 29 Sep 2014 17:50:29 GMT\",\r\n        \"Content-Type\": \"application/json\"\r\n    },\r\n    \"data\": \"{\\n  \\\"origin\\\": \\\"159.14.243.254\\\"\\n}\"\r\n}\r\n```\r\n\r\nThe response contains all the elements of an HTTP response including code, reason, headers, and the data (which has been removed for brevity). In addition, the time (in milliseconds) the response was received and the elapsed time (in milliseconds) join the UUID and status metadata.\r\n\r\n### Canceling a request\r\n\r\nThis is called the HTTP **Task** Queue because it was developed to support a common need when using a service-based communication (e.g. request/response) for performing a task such as executing a database query, performing an analysis, etc. Once the request is sent the client could abort the request however the server will continue to execute the task. htq defines an interface for services to implement for allowing requests to be canceled. For example, if I send a request that is taking longer than I expect (delayed for 30 seconds):\r\n\r\n```bash\r\n$ curl -i -X POST -H Content-Type:application/json http://localhost:5000 -d '{\"url\": \"http://httpbin.org/delay/30\"}'\r\nHTTP/1.0 303 SEE OTHER\r\nContent-Type: text/html; charset=utf-8\r\nContent-Length: 0\r\nLocation: http://localhost:5000/1686e1b7-3b05-4d45-95e8-caf934f540aa/\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 18:00:28 GMT\r\n```\r\n\r\nThen I can send a DELETE to the request URL:\r\n\r\n```bash\r\n$ curl -i -X DELETE http://localhost:5000/1686e1b7-3b05-4d45-95e8-caf934f540aa/\r\nHTTP/1.0 204 NO CONTENT\r\nContent-Type: text/html; charset=utf-8\r\nContent-Length: 0\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 18:00:41 GMT\r\n```\r\n\r\nNow if we check the status, we should see the status has changed to `canceled` (the response is also empty).\r\n\r\n```bash\r\n$ curl -i http://localhost:5000/9619b267-760d-4f0a-9f15-eb8ad99cd1c4/status/\r\nHTTP/1.0 200 OK\r\nContent-Type: application/json\r\nContent-Length: 22\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 18:01:23 GMT\r\n\r\n{\"status\": \"canceled\"}\r\n```\r\n\r\nInternally this interrupts the request, but also sends a DELETE request to the endpoint (in this `http://httpbin.org/delay/30`). Implementors of services can support the DELETE request to cancel the underlying processing that is occurring. Of course this is specific to the underlying task being performed, but this simple service-level contract provides a consistent mechanism for signaling the the cancellation.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}