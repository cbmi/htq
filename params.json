{"name":"HTTP Task Queue (HTQ)","tagline":"Queues HTTP requests and stores the response in Redis for later retrieval","body":"# HTTP Task Queue (htq)\r\n\r\nThe motivation for this project is to provide a standard interface for sending a request in the background to a service that performs some task with a standard mechanism for signaling it to be *cancelled*.\r\n\r\nIn this context, a *task* is classified as something that may take longer than what is appropriate for a typical HTTP response or something that is allowed to be eventually completed. Examples include executing a database query, running an analysis on some data, and injesting/scraping data from websites or other services. One side effect of the client-server model is that the server may not be aware if the client aborts the request. The server will continue to perform the task using up resources that other tasks or request handlers could be using. The mechanism for signaling a cancellation is for a subsequent DELETE request to be sent to the service which can be handled to interrupt the first request. This of course requires services to support the DELETE method and implement the logic for cancelling the task being performed. See below for a working example of a [service](#service-example) implementing this interface.\r\n\r\nFor a detailed introduction, read the [tutorial](#tutorial) below. \r\n\r\n## Dependencies\r\n\r\n- Python 3.3+\r\n- Redis 2.4+\r\n\r\n## Command-line Interface\r\n\r\n```\r\n$ htq -h\r\nHTTP Task Queue (htq) command-line interface\r\n\r\nUsage:\r\n    htq server [--host <host>] [--port <port>] [--redis <redis>] [--debug]\r\n    htq worker [--threads <n>] [--redis <redis>] [--debug]\r\n\r\nOptions:\r\n    -h --help           Show this screen.\r\n    -v --version        Show version.\r\n    --debug             Turns on debug logging.\r\n    --host <host>       Host of the HTTP service [default: localhost].\r\n    --port <port>       Port of the HTTP service [default: 5000].\r\n    --redis <redis>     Host/port of the Redis server [default: localhost:6379].\r\n    --threads <n>       Number of threads a worker should spawn [default: 10].\r\n```\r\n\r\nRun the server for the HTTP REST interface.\r\n\r\n```\r\nhtq server\r\n```\r\n\r\nRun the worker to send requests and receive responses.\r\n\r\n```\r\nhtq worker\r\n```\r\n\r\n## API\r\n\r\n- `GET /` - Gets all queued requests.\r\n- `POST /` - Sends (queues) a request\r\n- `GET /<uuid>/` - Gets a request by UUID\r\n- `DELETE /<uuid>/` - Cancels a request, deleting it's response if already received\r\n- `GET /<uuid>/response/` - Gets a request's response if it has been received\r\n- `DELETE /<uuid>/response/` - Delete a request's response to clear up space\r\n\r\n## Tutorial\r\n\r\nStart the HTQ server:\r\n\r\n```bash\r\n$ htq server\r\nStarting htq REST server...\r\n * Running on http://localhost:5000/\r\n```\r\n\r\nSend a POST to the service with a JSON encoded structure of the request to be sent. This immediately returns a `303 See Other` response with the `Location` header to the request\r\n\r\n```bash\r\n$ curl -i -X POST -H 'Content-Type: application/json' http://localhost:5000 -d '{\"url\": \"http://httpbin.org/ip\"}'\r\nHTTP/1.0 303 SEE OTHER\r\nContent-Type: text/html; charset=utf-8\r\nContent-Length: 0\r\nLocation: http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 17:18:49 GMT\r\n```\r\n\r\nSee what the request resource looks like (use the URL from the `Location` header in your output):\r\n\r\n```bash\r\n$ curl -i http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/\r\nHTTP/1.0 200 OK\r\nContent-Type: application/json\r\nContent-Length: 185\r\nLink: <http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/response/>; rel=\"response\",\r\n      <http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/>; rel=\"self\",\r\n      <http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/status/>; rel=\"status\"\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 17:26:05 GMT\r\n\r\n{\r\n    \"timeout\": 60,\r\n    \"status\": \"queued\",\r\n    \"data\": null,\r\n    \"headers\": {},\r\n    \"url\": \"http://httpbin.org/ip\",\r\n    \"method\": \"get\",\r\n    \"uuid\": \"a936e1a1-68d8-4433-a0c0-4f4b2111670d\",\r\n    \"time\": 1412011537783\r\n}\r\n```\r\n\r\nThe above response shows the details of the request such as the URL, method, headers, and request data. Additionally metadata has been captured when the request was queued including the UUID, the time (in milliseconds) when the request was queued, the status of the request and a timeout. The `Link` header shows the related links from this resource including one to the response and the status. The status link is a lightweight:\r\n\r\n\r\n```bash\r\n$ curl -i http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/status/\r\nHTTP/1.0 200 OK\r\nContent-Type: application/json\r\nContent-Length: 20\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 17:30:21 GMT\r\n\r\n{\"status\": \"queued\"}\r\n```\r\n\r\nIf we were to `curl` the response link, it would block until the response is ready. Since we have not started a worker yet, this would be forever. Let's start a worker to actual send the request. Execute this in a separate shell:\r\n\r\n```bash\r\n$ htq worker --debug\r\nStarted 10 workers...\r\n[a936e1a1-68d8-4433-a0c0-4f4b2111670d] sending request...\r\n[a936e1a1-68d8-4433-a0c0-4f4b2111670d] response received\r\n```\r\n\r\nStarting the worker daemon immediately starts consuming the queue and sending the requests. As you can see, the one sent above has been sent and the response received. Let's check the status of our request.\r\n\r\n```bash\r\n$ curl -i http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/status/\r\nHTTP/1.0 200 OK\r\nContent-Type: application/json\r\nContent-Length: 21\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 17:36:56 GMT\r\n\r\n{\"status\": \"success\"}\r\n```\r\n\r\nSuccess! Now let's use the link to the response itself.\r\n\r\n```bash\r\n$ curl -i http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/response/\r\nHTTP/1.0 200 OK\r\nContent-Type: application/json\r\nContent-Length: 19291\r\nLink: <http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/>; rel=\"request\",\r\n      <http://localhost:5000/a936e1a1-68d8-4433-a0c0-4f4b2111670d/response/>; rel=\"self\"\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 17:38:22 GMT\r\n\r\n{\r\n    \"status\": \"success\",\r\n    \"time\": 1412012019457,\r\n    \"code\": 200,\r\n    \"reason\": \"OK\",\r\n    \"elapsed\": 79.81,\r\n    \"uuid\": \"62db48a4-e511-4c8e-9c11-32b39758d1ff\",\r\n    \"headers\": {\r\n        \"Age\": \"0\",\r\n        \"Content-Length\": \"32\",\r\n        \"Connection\": \"Keep-Alive\",\r\n        \"Access-Control-Allow-Origin\": \"*\",\r\n        \"Server\": \"gunicorn/18.0\",\r\n        \"Access-Control-Allow-Credentials\": \"true\",\r\n        \"Date\": \"Mon, 29 Sep 2014 17:50:29 GMT\",\r\n        \"Content-Type\": \"application/json\"\r\n    },\r\n    \"data\": \"{\\n  \\\"origin\\\": \\\"159.14.243.254\\\"\\n}\"\r\n}\r\n```\r\n\r\nThe response contains all the elements of an HTTP response including code, reason, headers, and the data (which has been removed for brevity). In addition, the time (in milliseconds) the response was received and the elapsed time (in milliseconds) join the UUID and status metadata.\r\n\r\n### Canceling a request\r\n\r\nHTQ defines an interface for services to implement for allowing requests to be canceled. For example, if I send a request that is taking longer than I expect (delayed for 30 seconds):\r\n\r\n```bash\r\n$ curl -i -X POST -H Content-Type:application/json http://localhost:5000 -d '{\"url\": \"http://httpbin.org/delay/30\"}'\r\nHTTP/1.0 303 SEE OTHER\r\nContent-Type: text/html; charset=utf-8\r\nContent-Length: 0\r\nLocation: http://localhost:5000/1686e1b7-3b05-4d45-95e8-caf934f540aa/\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 18:00:28 GMT\r\n```\r\n\r\nThen I can send a DELETE to the request URL:\r\n\r\n```bash\r\n$ curl -i -X DELETE http://localhost:5000/1686e1b7-3b05-4d45-95e8-caf934f540aa/\r\nHTTP/1.0 204 NO CONTENT\r\nContent-Type: text/html; charset=utf-8\r\nContent-Length: 0\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 18:00:41 GMT\r\n```\r\n\r\nNow if we check the status, we should see the status has changed to `canceled` (the response is also empty).\r\n\r\n```bash\r\n$ curl -i http://localhost:5000/9619b267-760d-4f0a-9f15-eb8ad99cd1c4/status/\r\nHTTP/1.0 200 OK\r\nContent-Type: application/json\r\nContent-Length: 22\r\nServer: Werkzeug/0.9.6 Python/3.4.1\r\nDate: Mon, 29 Sep 2014 18:01:23 GMT\r\n\r\n{\"status\": \"canceled\"}\r\n```\r\n\r\nInternally this interrupts the request, but also sends a DELETE request to the endpoint (in this `http://httpbin.org/delay/30`). Implementors of services can support the DELETE request to cancel the underlying processing that is occurring. Of course this is specific to the underlying task being performed, but this simple service-level contract provides a consistent mechanism for signaling the the cancellation.\r\n\r\n## Service Example\r\n\r\nBelow is a working example of a service that implements the interface HTQ requires for receiving the DELETE to signal the cancellation. This service takes a JSON-encoded statement and parameters and executes them in a local PostgreSQL instance (for simplicity, the database settings are hard-coded).\r\n\r\n```python\r\nimport json\r\nimport logging\r\nimport psycopg2\r\nfrom flask import Flask, abort, request\r\n\r\nlogger = logging.getLogger(__name__)\r\nlogger.setLevel(logging.DEBUG)\r\nhandler = logging.StreamHandler()\r\nlogger.addHandler(handler)\r\n\r\napp = Flask(__name__)\r\n\r\n# Database connection settings\r\nsettings = {\r\n    'dbname': 'example',\r\n    'host': 'localhost',\r\n}\r\n\r\n# Currently running tasks by UUID mapped to the\r\n# connection process ID\r\ntasks = {}\r\n\r\n\r\n@app.route('/<uuid>/', methods=['POST'])\r\ndef run(uuid):\r\n    data = request.json\r\n\r\n    conn = psycopg2.connect(**settings)\r\n    c = conn.cursor()\r\n\r\n    # Store the PID of the connection execute this task\r\n    pid = conn.get_backend_pid()\r\n    tasks[uuid] = pid\r\n\r\n    try:\r\n        logger.debug('[{}] executing query for {}...'.format(pid, uuid))\r\n        c.execute(data['statement'], data.get('parameters'))\r\n    except:\r\n        conn.cancel()\r\n        abort(500)\r\n    finally:\r\n        tasks.pop(uuid, None)\r\n\r\n    return json.dumps(c.fetchall()), 200\r\n\r\n\r\n@app.route('/<uuid>/', methods=['DELETE'])\r\ndef cancel(uuid):\r\n    if uuid not in tasks:\r\n        abort(404)\r\n\r\n    pid = tasks.pop(uuid)\r\n\r\n    # Open new connection to cancel the query\r\n    conn = psycopg2.connect(**settings)\r\n    c = conn.cursor()\r\n\r\n    c.execute('select pg_terminate_backend(%s)', (pid,))\r\n    logger.debug('[{}] canceled query for {}'.format(pid, uuid))\r\n\r\n    return '', 204\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(threaded=True)\r\n```\r\n\r\nThe interaction looks as follows:\r\n\r\n```bash\r\n% python example_service.py\r\n * Running on http://127.0.0.1:5000/\r\n[57819] executing query for abc123...\r\n[57819] canceled query for abc123\r\n127.0.0.1 - - [30/Sep/2014 11:16:01] \"DELETE /abc123/ HTTP/1.1\" 204 -\r\n127.0.0.1 - - [30/Sep/2014 11:16:02] \"POST /abc123/ HTTP/1.1\" 500 -\r\n```\r\n\r\nA POST request was first sent to execute a query. A DELETE request was sent shortly after to cancel the query and returns. When the POST request does respond it is a 500 complaining the connection was closed (which is what we wanted).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}